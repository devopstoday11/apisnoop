# -*- ii: apisnoop; -*-
#+TITLE: Mock Ticket Template
#+AUTHOR: ii team
#+TODO: TODO(t) NEXT(n) IN-PROGRESS(i) BLOCKED(b) | DONE(d)
#+OPTIONS: toc:nil tags:nil todo:nil
#+EXPORT_SELECT_TAGS: export
* TODO [0%] In-Cluster Setup                                    :neverexport:
  :PROPERTIES:
  :LOGGING:  nil
  :END:
** TODO Connect demo to right eye

   #+begin_src tmate :session foo:hello :eval never-export
     echo "What parts of Kubernetes do you depend on $USER?"
   #+end_src
** Tilt Up
   #+begin_src tmate :session foo:hello :eval never-export
     cd ~/apisnoop
     tilt up --host 0.0.0.0
   #+end_src
** TODO Verify Pods Running
   #+begin_src shell
     kubectl get pods
   #+end_src

   #+RESULTS:
   #+begin_example
   NAME                                    READY   STATUS    RESTARTS   AGE
   apisnoop-auditlogger-86dcf97749-nb2rp   1/1     Running   1          6d23h
   hasura-7c5775fc95-rmp28                 1/1     Running   1          6d23h
   kubemacs-0                              1/1     Running   1          6d23h
   pgadmin-78b7448594-bmvxl                1/1     Running   0          6d23h
   postgres-6dbf95b969-hpr7k               1/1     Running   0          6d23h
   webapp-5bd67b658b-fc6pr                 1/1     Running   0          6d23h
   #+end_example

** TODO Check it all worked

   #+begin_src sql-mode :results replace
     \d+
   #+end_src

   #+RESULTS:
   #+begin_SRC example
                                                                              List of relations
    Schema |               Name               |       Type        |  Owner   |  Size   |                                    Description                                    
   --------+----------------------------------+-------------------+----------+---------+-----------------------------------------------------------------------------------
    public | api_operation                    | view              | apisnoop | 0 bytes | 
    public | api_operation_material           | materialized view | apisnoop | 3056 kB | details on each operation_id as taken from the openAPI spec
    public | api_operation_parameter_material | materialized view | apisnoop | 5008 kB | the parameters for each operation_id in open API spec
    public | audit_event                      | view              | apisnoop | 0 bytes | a record for each audit event in an audit log
    public | bucket_job_swagger               | table             | apisnoop | 3128 kB | metadata for audit events  and their respective swagger.json
    public | endpoint_coverage                | view              | apisnoop | 0 bytes | the test hits and conformance test hits per operation_id & other useful details
    public | endpoint_coverage_material       | materialized view | apisnoop | 144 kB  | 
    public | endpoints_hit_by_new_test        | view              | apisnoop | 0 bytes | list endpoints hit during our live auditing alongside their current test coverage
    public | projected_change_in_coverage     | view              | apisnoop | 0 bytes | overview of coverage stats if the e2e suite included your tests
    public | raw_audit_event                  | table             | apisnoop | 4405 MB | a record for each audit event in an audit log
    public | stable_endpoint_stats            | view              | apisnoop | 0 bytes | coverage stats for entire test run, looking only at its stable endpoints
    public | tests                            | view              | apisnoop | 0 bytes | 
    public | untested_stable_core_endpoints   | view              | apisnoop | 0 bytes | list stable core endpoints not hit by any tests, according to their test run
    public | useragents                       | view              | apisnoop | 0 bytes | 
   (14 rows)

   #+end_SRC

** TODO Check current coverage
   #+NAME: stable endpoint stats
   #+begin_src sql-mode
     select * from stable_endpoint_stats where job != 'live';
   #+end_src

   #+RESULTS: stable endpoint stats
   #+begin_SRC example
            job         |    date    | total_endpoints | test_hits | conf_hits | percent_tested | percent_conf_tested 
   ---------------------+------------+-----------------+-----------+-----------+----------------+---------------------
    1229108788603129860 | 2020-02-16 |             438 |       190 |       138 |          43.38 |               31.51
   (1 row)

   #+end_SRC

* Identifying an untested feature Using APISnoop                     :export:

According to this APIsnoop query, there are still some remaining Deployment endpoints which are untested.

  #+NAME: untested_stable_core_endpoints
  #+begin_src sql-mode :eval never-export :exports both :session none
    SELECT
      operation_id,
      -- k8s_action,
      -- path,
      -- description,
      kind
      FROM untested_stable_endpoints
      where kind like 'Deployment'
      -- WHERE operation_id ilike '%Deployment%'
     ORDER BY kind,operation_id desc
     LIMIT 25
           ;
  #+end_src

 #+RESULTS: untested_stable_core_endpoints
 #+begin_SRC example
                 operation_id                |    kind    
 --------------------------------------------+------------
  replaceAppsV1NamespacedDeploymentStatus    | Deployment
  readAppsV1NamespacedDeploymentStatus       | Deployment
  patchAppsV1NamespacedDeploymentStatus      | Deployment
  patchAppsV1NamespacedDeployment            | Deployment
  listAppsV1DeploymentForAllNamespaces       | Deployment
  deleteAppsV1CollectionNamespacedDeployment | Deployment
 (6 rows)

 #+end_SRC

* API Reference and feature documentation                            :export:
- [[https://kubernetes.io/docs/reference/kubernetes-api/][Kubernetes API Reference Docs]]
- [[https://github.com/kubernetes/client-go/blob/master/kubernetes/typed/core/v1/Deployment.go][client-go - Deployment]] 

* The mock test                                                      :export:
** Test outline
1. Create a Deployment with a static label

2. Patch the Deployment with a new Label and updated data

3. Get the Deployment to ensure it's patched

4. List all Deployments in all Namespaces
   find the Deployment(1)
   ensure that the Deployment is found and is patched

5. Delete Namespaced Deployment(1) via a Collection with a LabelSelector

** Test the functionality in Go
   #+begin_src go
     package main

     import (
       "encoding/json"
       "fmt"
       "flag"
       "os"
       v1 "k8s.io/api/core/v1"
       appsv1 "k8s.io/api/apps/v1"
       "k8s.io/client-go/dynamic"
       "k8s.io/apimachinery/pkg/runtime"
       "k8s.io/apimachinery/pkg/runtime/schema"
       //"k8s.io/apimachinery/pkg/conversion/unstructured"
       unstructuredv1 "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
       metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
       "k8s.io/client-go/kubernetes"
       "k8s.io/apimachinery/pkg/types"
       "k8s.io/client-go/tools/clientcmd"
       watch "k8s.io/apimachinery/pkg/watch"
     )

     func main() {
       // uses the current context in kubeconfig
       kubeconfig := flag.String("kubeconfig", fmt.Sprintf("%v/%v/%v", os.Getenv("HOME"), ".kube", "config"), "(optional) absolute path to the kubeconfig file")
       flag.Parse()
       config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
       if err != nil {
           fmt.Println(err)
           return
       }
       // make our work easier to find in the audit_event queries
       config.UserAgent = "live-test-writing"
       // creates the clientset
       ClientSet, _ := kubernetes.NewForConfig(config)
       DynamicClientSet, _ := dynamic.NewForConfig(config)
       deploymentResource := schema.GroupVersionResource{Group: "apps", Version: "v1", Resource: "deployments"}

       testDeploymentName := "test-deployment"
       testDeploymentInitialImage := "nginx"
       testDeploymentPatchImage := "alpine"
       testDeploymentUpdateImage := "httpd"
       testDeploymentDefaultReplicas := int32(3)
       testDeploymentMinimumReplicas := int32(1)
       testDeploymentNoReplicas := int32(0)
       testDeploymentLabelSelectors := metav1.LabelSelector{
           MatchLabels: map[string]string{"app": "test-deployment"},
       }
       testNamespaceName := "default"

       fmt.Println("creating a Deployment")
       testDeployment := appsv1.Deployment{
           ObjectMeta: metav1.ObjectMeta{
               Name: testDeploymentName,
               Labels: map[string]string{"test-deployment-static": "true"},
           },
           Spec: appsv1.DeploymentSpec{
               Replicas: &testDeploymentDefaultReplicas,
               Selector: &testDeploymentLabelSelectors,
               Template: v1.PodTemplateSpec{
                   ObjectMeta: metav1.ObjectMeta{
                       Labels: testDeploymentLabelSelectors.MatchLabels,
                   },
                   Spec: v1.PodSpec{
                       Containers: []v1.Container{{
                           Name: testDeploymentName,
                           Image: testDeploymentInitialImage,
                       }},
                   },
               },
           },
       }
       _, err = ClientSet.AppsV1().Deployments(testNamespaceName).Create(&testDeployment)
       if err != nil {
           fmt.Println(err)
           return
       }

       fmt.Println("watching for the Deployment to be added")
       dplmtWatchTimeoutSeconds := int64(180)
       dplmtWatch, err := ClientSet.AppsV1().Deployments(testNamespaceName).Watch(metav1.ListOptions{LabelSelector: "test-deployment-static=true", TimeoutSeconds: &dplmtWatchTimeoutSeconds})
       if err != nil {
           fmt.Println(err, "Failed to setup watch on newly created Deployment")
           return
       }

       dplmtWatchChan := dplmtWatch.ResultChan()
       for event := range dplmtWatchChan {
           if event.Type == watch.Added {
               break
           }
       }
       defer func() {
         fmt.Println("deleting the Deployment")
         err = ClientSet.AppsV1().Deployments(testNamespaceName).DeleteCollection(&metav1.DeleteOptions{}, metav1.ListOptions{LabelSelector: "test-deployment-static=true"})
         if err != nil {
           fmt.Println(err)
           return
         }
         for event := range dplmtWatchChan {
           deployment, ok := event.Object.(*appsv1.Deployment)
           if ok != true {
             fmt.Println("unable to convert event.Object type")
             return
           }
           if event.Type == watch.Deleted && deployment.ObjectMeta.Name == testDeploymentName {
             break
           }
         }
       }()
       fmt.Println("waiting for all Replicas to be Ready")
       for event := range dplmtWatchChan {
           deployment, ok := event.Object.(*appsv1.Deployment)
           if ok != true {
               fmt.Println("unable to convert event.Object type")
               return
           }
           if deployment.Status.AvailableReplicas == testDeploymentDefaultReplicas &&
              deployment.Status.ReadyReplicas == testDeploymentDefaultReplicas {
               break
           }
       }

       fmt.Println("patching the Deployment")
       deploymentPatch, err := json.Marshal(map[string]interface{}{
           "metadata": map[string]interface{}{
               "labels": map[string]string{"test-deployment": "patched"},
           },
           "spec": map[string]interface{}{
               "replicas": testDeploymentMinimumReplicas,
               "template": map[string]interface{}{
                   "spec": map[string]interface{}{
                       "containers": []map[string]interface{}{{
                           "name": testDeploymentName,
                           "image": testDeploymentPatchImage,
                           "command": []string{"/bin/sleep", "100000"},
                       }},
                   },
               },
           },
       })
       if err != nil {
           fmt.Println(err, "failed to Marshal Deployment JSON patch")
           return
       }
       _, err = ClientSet.AppsV1().Deployments(testNamespaceName).Patch(testDeploymentName, types.StrategicMergePatchType, []byte(deploymentPatch))
       if err != nil {
            fmt.Println(err, "failed to patch Deployment")
            return
       }

       for event := range dplmtWatchChan {
           if event.Type == watch.Modified {
               break
           }
       }
       fmt.Println("waiting for Replicas to scale")
       for event := range dplmtWatchChan {
           deployment, ok := event.Object.(*appsv1.Deployment)
           if ok != true {
               fmt.Println("unable to convert event.Object type")
               return
           }
           if deployment.Status.AvailableReplicas == testDeploymentMinimumReplicas &&
              deployment.Status.ReadyReplicas == testDeploymentMinimumReplicas {
               break
           }
       }


       fmt.Println("listing Deployments")
       deploymentsList, err := ClientSet.AppsV1().Deployments("").List(metav1.ListOptions{LabelSelector: "test-deployment-static=true"})
       if err != nil {
           fmt.Println(err, "failed to list Deployments")
           return
       }
       foundDeployment := false
       for _, deploymentItem := range deploymentsList.Items {
           if deploymentItem.ObjectMeta.Name == testDeploymentName &&
              deploymentItem.ObjectMeta.Namespace == testNamespaceName &&
              deploymentItem.ObjectMeta.Labels["test-deployment-static"] == "true" &&
              ,*deploymentItem.Spec.Replicas == testDeploymentMinimumReplicas &&
              deploymentItem.Spec.Template.Spec.Containers[0].Image == testDeploymentPatchImage {
               foundDeployment = true
               break
           }
       }
       if foundDeployment != true {
           fmt.Println("unable to find the Deployment in list")
           return
       }

       fmt.Println("updating the DeploymentStatus")
       testDeploymentUpdate := testDeployment
       testDeploymentUpdate.ObjectMeta.Labels["test-deployment"] = "updated"
       testDeploymentUpdate.Spec.Template.Spec.Containers[0].Image = testDeploymentUpdateImage
       testDeploymentDefaultReplicasPointer := &testDeploymentDefaultReplicas
       testDeploymentUpdate.Spec.Replicas = testDeploymentDefaultReplicasPointer
       testDeploymentUpdate.Status.ReadyReplicas = testDeploymentNoReplicas
       testDeploymentUpdateUnstructuredMap, err := runtime.DefaultUnstructuredConverter.ToUnstructured(&testDeploymentUpdate)
       if err != nil {
           fmt.Println(err, "failed to convert to unstructured")
       }
       testDeploymentUpdateUnstructured := unstructuredv1.Unstructured{
           Object: testDeploymentUpdateUnstructuredMap,
       }
	     // currently this hasn't been able to hit the endpoint replaceAppsV1NamespacedDeploymentStatus
       _, err = DynamicClientSet.Resource(deploymentResource).Namespace(testNamespaceName).Update(&testDeploymentUpdateUnstructured, metav1.UpdateOptions{})//, "status")
       if err != nil {
           fmt.Println(err, "failed to update the DeploymentStatus")
           return
       }
       for event := range dplmtWatchChan {
           if event.Type == watch.Modified {
               break
           }
       }

       fmt.Println("fetching the DeploymentStatus")
       deploymentGetUnstructured, err := DynamicClientSet.Resource(deploymentResource).Namespace(testNamespaceName).Get(testDeploymentName, metav1.GetOptions{}, "status")
       if err != nil {
           fmt.Println(err, "failed to fetch the Deployment")
           return
       }
       deploymentGet := appsv1.Deployment{}
       err = runtime.DefaultUnstructuredConverter.FromUnstructured(deploymentGetUnstructured.Object, &deploymentGet)
       if err != nil {
           fmt.Println(err, "failed to convert the unstructured response to a Deployment")
           return
       }
       if ! (deploymentGet.Spec.Template.Spec.Containers[0].Image == testDeploymentUpdateImage || deploymentGet.Status.ReadyReplicas == testDeploymentNoReplicas || deploymentGet.ObjectMeta.Labels["test-deployment"] == "updated") {
           fmt.Println("failed to update the Deployment (did not return correct values)")
           return
       }
       for event := range dplmtWatchChan {
           if event.Type == watch.Modified {
               break
           }
       }
       for event := range dplmtWatchChan {
           deployment, ok := event.Object.(*appsv1.Deployment)
           if ok != true {
               fmt.Println("failed to convert event Object to a Deployment")
               return
           }
           if deployment.Status.ReadyReplicas == testDeploymentDefaultReplicas {
               break
           }
       }

       fmt.Println("patching the DeploymentStatus")
       deploymentStatusPatch, err := json.Marshal(map[string]interface{}{
           "metadata": map[string]interface{}{
               "labels": map[string]string{"test-deployment": "patched-status"},
           },
           "status": map[string]interface{}{
               "readyReplicas": testDeploymentNoReplicas,
           },
       })
       if err != nil {
           fmt.Println(err, "failed to Marshal Deployment JSON patch")
           return
       }
       DynamicClientSet.Resource(deploymentResource).Namespace(testNamespaceName).Patch(testDeploymentName, types.StrategicMergePatchType, []byte(deploymentStatusPatch), metav1.PatchOptions{}, "status")

       fmt.Println("fetching the DeploymentStatus")
       deploymentGetUnstructured, err = DynamicClientSet.Resource(deploymentResource).Namespace(testNamespaceName).Get(testDeploymentName, metav1.GetOptions{}, "status")
       if err != nil {
           fmt.Println(err, "failed to fetch the DeploymentStatus")
           return
       }
       deploymentGet = appsv1.Deployment{}
       err = runtime.DefaultUnstructuredConverter.FromUnstructured(deploymentGetUnstructured.Object, &deploymentGet)
       if err != nil {
           fmt.Println(err, "failed to convert the unstructured response to a Deployment")
           return
       }
       if ! (deploymentGet.Spec.Template.Spec.Containers[0].Image == testDeploymentUpdateImage || deploymentGet.Status.ReadyReplicas == 0 || deploymentGet.ObjectMeta.Labels["test-deployment"] == "patched-status") {
           fmt.Println("failed to update the Deployment (did not return correct values)")
           return
       }
       for event := range dplmtWatchChan {
           if event.Type == watch.Modified {
               break
           }
       }
       for event := range dplmtWatchChan {
           deployment, ok := event.Object.(*appsv1.Deployment)
           if ok != true {
               fmt.Println("failed to convert event Object to a Deployment")
               return
           }
           if deployment.Status.ReadyReplicas == testDeploymentDefaultReplicas {
               break
           }
       }

       // write test here
       fmt.Println("[status] complete")
     }
   #+end_src

   #+RESULTS:
   #+begin_src go
   creating a Deployment
   watching for the Deployment to be added
   waiting for all Replicas to be Ready
   patching the Deployment
   waiting for Replicas to scale
   listing Deployments
   updating the DeploymentStatus
   fetching the DeploymentStatus
   patching the DeploymentStatus
   fetching the DeploymentStatus
   [status] complete
   deleting the Deployment
   #+end_src

* Verifying increase it coverage with APISnoop                       :export:
Discover useragents:
  #+begin_src sql-mode :eval never-export :exports both :session none
    select distinct useragent from audit_event where bucket='apisnoop' and useragent not like 'kube%' and useragent not like 'coredns%' and useragent not like 'kindnetd%' and useragent like 'live%';
  #+end_src

  #+RESULTS:
  #+begin_SRC example
       useragent     
  -------------------
   live-test-writing
  (1 row)

  #+end_SRC

List endpoints hit by the test:
#+begin_src sql-mode :exports both :session none
select * from endpoints_hit_by_new_test where useragent like 'live%'; 
#+end_src

#+RESULTS:
#+begin_SRC example
     useragent     |                operation_id                | hit_by_ete | hit_by_new_test 
-------------------+--------------------------------------------+------------+-----------------
 live-test-writing | createAppsV1NamespacedDeployment           | t          |               1
 live-test-writing | deleteAppsV1CollectionNamespacedDeployment | f          |               1
 live-test-writing | listAppsV1DeploymentForAllNamespaces       | f          |               1
 live-test-writing | listAppsV1NamespacedDeployment             | t          |               1
 live-test-writing | patchAppsV1NamespacedDeployment            | f          |               1
 live-test-writing | patchAppsV1NamespacedDeploymentStatus      | f          |               1
 live-test-writing | readAppsV1NamespacedDeploymentStatus       | f          |               2
 live-test-writing | replaceAppsV1NamespacedDeployment          | t          |               1
(8 rows)

#+end_SRC

Display endpoint coverage change:
  #+begin_src sql-mode :eval never-export :exports both :session none
    select * from projected_change_in_coverage;
  #+end_src

  #+RESULTS:
  #+begin_SRC example
     category    | total_endpoints | old_coverage | new_coverage | change_in_number 
  ---------------+-----------------+--------------+--------------+------------------
   test_coverage |             445 |          181 |          186 |                5
  (1 row)

  #+end_SRC

* Final notes :export:
If a test with these calls gets merged, **test coverage will go up by 5 points**

This test is also created with the goal of conformance promotion.

-----  
/sig testing  

/sig architecture  

/area conformance  

* Options :neverexport:
** Delete all events after postgres initialization
   #+begin_src sql-mode :eval never-export :exports both :session none
   delete from audit_event where bucket = 'apisnoop' and job='live';
   #+end_src

   #+RESULTS:
   #+begin_SRC example
   DELETE 19526
   #+end_SRC

* Open Tasks
  Set any open tasks here, using org-todo
** DONE Live Your Best Life
* Footnotes                                                     :neverexport:
  :PROPERTIES:
  :CUSTOM_ID: footnotes
  :END:
